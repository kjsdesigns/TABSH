=== README.md CONTENT ===
I'm working on a tower defense game.  I'll be sending you complete files that make up the game, then requesting changes.  Before you recommend changes, evaluate if you're missing any relevant files and ask me for them (instead of making assumptions).  Similarly, if you have a couple ways of making it work, ask me before providing multiple full solutions.

Before providing the solution, evaluate if the files in question are getting too large and should be split up or otherwise refactored.  Any time there's any evidence of doing the same thing in 2 places identify that.  Summarize any file organization or modularity changes to me and ask me if I want to proceed with them before giving me the solution.

Ignore the python directory.

When delivering the solution, deliver the content of a shell script file that can be executed within the root directory of the project.  The shell script (I'll call my "udpdate script" should:
1. Overwrite the complete text of any files that are necessary to change to make the updates.  

2. At the end, check in all changes with an appropriate commit message based on the nature of the changes (replace "commet changes" in string with changes description), execute command: 
git add . && git commit -m "Commit message" && git push

3. I will copy the outputted shell script, and paste and run it on the root directory to implement the changes.

=== Local hosting ===

Using command within project directory:

cd /Users/keith/Documents/TABSH
python3 -m http.server 8000 --bind 0.0.0.0
http://192.168.0.13:8000

=== REPO FILE STRUCTURE ===
Directories:
  .
  asset_source
  assets
  assets/enemies
  assets/maps
  css
  js
  js/maps
  python
  python/assets/enemies
  python/assets/maps

Files:
  .DS_Store
  LICENSE
  README.md
  asset_source/level1.pxd
  asset_source/level1_enemies.pxd
  assets/.DS_Store
  assets/enemies/drone.png
  assets/enemies/leaf_blower.png
  assets/enemies/trench_digger.png
  assets/enemies/trench_walker.png
  assets/maps/level1.png
  css/style.css
  index.html
  js/.DS_Store
  js/assetLoader.js
  js/dataManager.js
  js/enemyManager.js
  js/game.js
  js/main.js
  js/maps/level1.js
  js/towerManager.js
  js/uiManager.js
  js/waveManager.js
  python/assets/enemies/drone.png
  python/assets/enemies/leaf_blower.png
  python/assets/enemies/trench_digger.png
  python/assets/enemies/trench_walker.png
  python/assets/maps/level1.png
  python/enemy_manager.py
  python/game.py
  python/install.sh
  python/main.py
  python/repo.txt
  python/repo_to_text.sh
  python/requirements.txt
  python/tower_manager.py
  python/ui_manager.py
  python/wave_manager.py
  repo.txt
  repo_to_text.sh
  update_script.sh

=== FILE CONTENTS ===
=== css/style.css ===
/* Make the body relatively positioned, so absolutely positioned elements anchor to it */
body {
    margin: 0;
    padding: 0;
    background-color: #333;
    color: #eee;
    font-family: sans-serif;
    position: relative;
}

/* Game Container */
#gameContainer {
    position: relative;
    width: 800px;
    margin: 0 auto;
}

/* Top-right buttons (Pause, Speed, Settings) container */
#topButtons {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 6px;
}

/* Make all buttons more tap-friendly */
button,
.actionButton {
    padding: 6px 10px;
    cursor: pointer;
}

/* Action buttons share these styles */
.actionButton {
    background-color: #800;  /* Dark red */
    color: #fff;
    border: 1px solid #600;
    font-size: 12px;
    border-radius: 3px;
}

.actionButton:hover {
    background-color: #a00;  /* Slightly lighter on hover */
}

/* Game canvas styling (center + border) */
#gameCanvas {
    display: block;
    margin: 0 auto;
    background-color: #000;
    border: 2px solid #aaa;
}

/* Enemy stats panel at bottom-left */
#enemyStats {
    display: none;
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 6px;
    border: 1px solid #999;
    border-radius: 3px;
}

/* Constrain the enemy image to 80px max each dimension */
#enemyImage {
    max-width: 80px;
    max-height: 80px;
}

/* Tower creation/upgrade panel */
#towerSelectPanel {
    display: none;
    position: absolute;
    background: rgba(0,0,0,0.8);
    border: 1px solid #999;
    border-radius: 3px;
    padding: 5px;
    color: #fff;
}

/* Settings dialog */
#settingsDialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    width: 600px;
    background: rgba(0,0,0,0.85);
    border: 2px solid #999;
    border-radius: 8px;
    transform: translate(-50%, -50%);
    z-index: 9999;
    padding: 10px;
}

/* Close button for the settings dialog */
#settingsDialogClose {
    float: right;
    cursor: pointer;
    margin-bottom: 10px;
}

/* "Settings" heading */
#settingsHeading {
    margin: 0;
    margin-bottom: 10px;
}

/* 2-column layout for settings content */
#settingsDialogContent {
    display: flex;
    flex-direction: row;
    gap: 15px;
}

/* Each column is 50% width so they are equal */
#settingsLeftColumn, #settingsRightColumn {
    width: 50%;
    box-sizing: border-box; /* ensure padding doesn't break the 50% layout */
}

/* Make the "Enemy HP" and "Starting gold" label consistent in styling */
#enemyHpLabel,
#startingGoldLabel {
    font-size: 12px;
    margin: 0;
    padding: 0;
}

/* The segmented HP buttons: smaller text, less padding */
.enemyHpOption {
    font-size: 10px;     
    padding: 3px 2px;    
    margin-right: 2px;
}

/* Debug table container + smaller text in table (by default 10px) */
#debugTableContainer {
    margin-top: 0;
    /* We'll reduce the entire right column's font size by 25% -> 0.75 scale */
    font-size: 0.75em;
}

#debugTable {
    border-collapse: collapse;
    border: 1px solid #999;
    width: 100%;
}

#debugTable th,
#debugTable td {
    padding: 4px 8px;
    border: 1px solid #666;
}

/* small label */
.smallInfoLabel {
    font-size: 12px;
    line-height: 1.2em;
}

/* Lose / Win messages (dialog style) */
#loseMessage,
#winMessage {
    display: none;
    text-align: center;
    font-family: sans-serif;
    margin-top: 20px;
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85);
    border: 2px solid #999;
    padding: 20px;
    border-radius: 8px;
    z-index: 9999;
}

=== index.html ===
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>My Tower Defense</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <!-- Wrap the canvas + buttons in a container so they're anchored relative to the canvas -->
    <div id="gameContainer">
      <!-- Game canvas -->
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      
      <!-- Container for speed, pause, settings buttons (top-right) -->
      <div id="topButtons">
        <button id="speedToggleButton" class="actionButton">1x</button>
        <!-- Pause/Resume button with icons -->
        <button id="pauseButton" class="actionButton">&#9658;</button>
        <!-- Gear icon for settings -->
        <button id="settingsButton" class="actionButton">&#9881;</button>
      </div>
    </div>

    <!-- Enemy stats UI (bottom-left) -->
    <div id="enemyStats">
      <img id="enemyImage" src="" alt="enemy">
      <div><strong id="enemyName">Name</strong></div>
      <div>HP: <span id="enemyHp"></span></div>
      <div>Speed: <span id="enemySpeed"></span></div>
      <div>Gold on Kill: <span id="enemyGold"></span></div>
    </div>

    <!-- Panel for tower creation/upgrade -->
    <div id="towerSelectPanel"></div>

    <!-- Settings dialog (hidden by default, 2-column layout) -->
    <div id="settingsDialog">
      <div id="settingsDialogClose">&#10006;</div>
      <h2 id="settingsHeading">Settings</h2>
      <div id="settingsDialogContent">
        <!-- LEFT column: current game info, enemy HP label & toggles, gold, restart -->
        <div id="settingsLeftColumn">
          <div id="currentGameLabel" class="smallInfoLabel"></div>
          <hr style="margin: 6px 0;" />

          <!-- "Enemy HP" label + segmented buttons -->
          <div id="enemyHpRow">
            <label id="enemyHpLabel">Enemy HP</label>
            <div id="enemyHpSegment"></div>
          </div>

          <!-- Starting gold + input -->
          <div id="startingGoldRow">
            <!-- Give this label an ID so we can style it the same as #enemyHpLabel -->
            <label id="startingGoldLabel" for="startingGoldInput">Starting gold</label>
            <input type="number" id="startingGoldInput" value="1000" />
          </div>

          <!-- Restart game button at bottom -->
          <button id="restartGameButton" class="actionButton" style="margin-top: 10px;">
            Restart Game
          </button>
        </div>

        <!-- RIGHT column: tower stats table -->
        <div id="settingsRightColumn">
          <div id="debugTableContainer">
            <table id="debugTable"></table>
          </div>
        </div>
      </div>
    </div>

    <!-- Lose message -->
    <div id="loseMessage">
      <h1 style="font-size: 3em; margin: 0;">You lost</h1>
      <div style="font-size: 6em;">X</div>
      <div style="margin-top: 10px;">
        <button id="loseRestartBtn" class="actionButton" style="margin-right: 10px;">Restart</button>
        <button id="loseSettingsBtn" class="actionButton">Settings</button>
      </div>
    </div>

    <!-- Win message -->
    <div id="winMessage">
      <h1 style="font-size: 3em; margin: 0;">You win!</h1>
      <div id="winStars" style="font-size: 4em; color: gold; margin-top: 10px;"></div>
      <div style="margin-top: 10px;">
        <button id="winRestartBtn" class="actionButton" style="margin-right: 10px;">Restart</button>
        <button id="winSettingsBtn" class="actionButton">Settings</button>
      </div>
    </div>

    <script type="module" src="./js/main.js"></script>
  </body>
</html>

=== js/assetLoader.js ===
/**
 * Test
 * assetLoader.js
 * 
 * Provides a unified function to load background and enemy images.
 */

function preloadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve(img);
      img.onerror = reject;
    });
  }
  
  /**
   * loadAllAssets(enemyTypes, backgroundSrc)
   * - enemyTypes: array of objects [{ name, src }, ...]
   * - backgroundSrc: string path to background image
   * 
   * Returns { loadedEnemies, loadedBackground }
   */
  export async function loadAllAssets(enemyTypes, backgroundSrc) {
    // 1) Preload background
    const bgPromise = preloadImage(backgroundSrc);
  
    // 2) Preload each enemy
    const enemyPromises = enemyTypes.map(async (type) => {
      const img = await preloadImage(type.src);
      const maxDim = 30;
      const scale = maxDim / Math.max(img.naturalWidth, img.naturalHeight);
      const w = Math.round(img.naturalWidth * scale);
      const h = Math.round(img.naturalHeight * scale);
      return {
        ...type,
        image: img,
        width: w,
        height: h,
        speed: 40,
      };
    });
  
    // Wait for everything
    const [loadedBackground, ...loadedEnemies] = await Promise.all([
      bgPromise,
      ...enemyPromises,
    ]);
  
    return {
      loadedEnemies,
      loadedBackground,
    };
  }
=== js/dataManager.js ===
/**
 * dataManager.js
 * 
 * Provides a function to load data from a Google Sheet.
 */

// Example function to fetch and parse data from a Google Sheets range.
export async function loadSheetData(sheetId, apiKey, range) {
    // Construct the Sheets API URL
    const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${range}?key=${apiKey}`;
  
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
  
      // Parse JSON returned by the Sheets API
      const json = await response.json();
  
      // The data is typically stored in json.values as a 2D array
      // Example: [["Name","Damage","Range"],["Archer Tower","10","150"]...]
      const rows = json.values;
      if (!rows || rows.length < 2) {
        // If no data or only a header row, return an empty array
        return [];
      }
  
      const headers = rows[0];
      const data = rows.slice(1).map((row) => {
        const obj = {};
        headers.forEach((header, i) => {
          // If a cell is missing, default to empty string
          obj[header] = row[i] !== undefined ? row[i] : "";
        });
        return obj;
      });
  
      return data;
    } catch (err) {
      console.error("Error fetching or parsing Sheets data:", err);
      return [];
    }
  }
=== js/enemyManager.js ===
export class EnemyManager {
  constructor(game) {
    this.game = game;

    // Internal data: "raw" stats before HP multipliers or random speed factor.
    // We'll apply the 20% global HP reduction on spawn, plus any wave multiplier,
    // plus the global game multiplier (game.globalEnemyHpMultiplier).
    this.enemyBaseData = {
      drone: {
        baseHp: 30,
        gold: 5,
        baseSpeed: 80,
      },
      leaf_blower: {
        baseHp: 60,
        gold: 8,
        baseSpeed: 60,
      },
      trench_digger: {
        baseHp: 100,
        gold: 12,
        baseSpeed: 30,
      },
      trench_walker: {
        baseHp: 150,
        gold: 15,
        baseSpeed: 25,
      },
    };

    // Holds the loaded images, widths, heights, etc. from assetLoader.js
    this.loadedEnemyAssets = [];
  }

  setLoadedEnemyAssets(loadedEnemies) {
    this.loadedEnemyAssets = loadedEnemies;
  }

  spawnEnemy(type, hpMultiplier = 1) {
    const baseData = this.enemyBaseData[type] || this.enemyBaseData["drone"];
    // Find matching image asset
    const asset = this.loadedEnemyAssets.find(e => e.name === type)
      || this.loadedEnemyAssets[0];

    // 20% global HP reduction, wave multiplier, plus global game multiplier
    const finalHp = baseData.baseHp
                    * 0.8
                    * hpMultiplier
                    * this.game.globalEnemyHpMultiplier;

    // Random speed ~ ±20% around baseSpeed
    const speedFactor = 0.8 + Math.random() * 0.4;
    const finalSpeed = baseData.baseSpeed * speedFactor;

    // Start at path[0]
    const path = this.game.path;
    if (!path || path.length === 0) {
      console.warn("No path defined in Game; cannot spawn enemy properly.");
      return;
    }
    const firstWP = path[0];

    // Create enemy object
    const enemy = {
      name: type,
      image: asset.image,
      width: asset.width,
      height: asset.height,
      x: firstWP.x,
      y: firstWP.y,
      hp: finalHp,
      baseHp: finalHp,
      speed: finalSpeed,
      gold: baseData.gold,
      waypointIndex: 1,
      dead: false,
    };

    // Add to game.enemies
    this.game.enemies.push(enemy);
  }

  update(deltaSec) {
    // Move enemies, handle death
    this.game.enemies.forEach(e => {
      this.updateEnemy(e, deltaSec);
      if (e.hp <= 0) {
        this.game.gold += e.gold || 0;
        e.dead = true;
        // If this was the selected enemy, clear selection
        if (this.game.uiManager && this.game.uiManager.selectedEnemy === e) {
          this.game.uiManager.selectedEnemy = null;
          this.game.uiManager.hideEnemyStats();
        }
      }
    });

    // Remove dead enemies or enemies that leave the screen
    this.game.enemies = this.game.enemies.filter(e => {
      if (e.dead) return false;

      // If the enemy is off-screen (x > this.game.width + e.width),
      // lose a life
      if (e.x > this.game.width + e.width) {
        this.game.lives -= 1;
        if (this.game.lives <= 0) {
          this.game.lives = 0;
          // Use UI manager to show "You lost"
          if (this.game.uiManager) {
            this.game.paused = true;
            this.game.uiManager.showLoseDialog();
          }
        }
        return false;
      }
      return true;
    });
  }

  updateEnemy(enemy, deltaSec) {
    const path = this.game.path;
    const nextWP = path[enemy.waypointIndex];
    if (!nextWP) {
      // No next WP => move off-screen
      enemy.x += enemy.speed * deltaSec;
      return;
    }

    // Move toward next waypoint
    const tx = nextWP.x;
    const ty = nextWP.y;
    const dx = tx - enemy.x;
    const dy = ty - enemy.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const step = enemy.speed * deltaSec;

    if (dist <= step) {
      enemy.x = tx;
      enemy.y = ty;
      enemy.waypointIndex++;
    } else {
      enemy.x += (dx / dist) * step;
      enemy.y += (dy / dist) * step;
    }
  }

  drawEnemy(ctx, enemy) {
    this.drawImageSafely(
      ctx,
      enemy.image,
      enemy.x - enemy.width / 2,
      enemy.y - enemy.height / 2,
      enemy.width,
      enemy.height
    );

    // HP bar
    if (enemy.hp < enemy.baseHp) {
      const barW = enemy.width;
      const barH = 4;
      const pct  = Math.max(0, enemy.hp / enemy.baseHp);

      const barX = enemy.x - barW / 2;
      const barY = enemy.y - enemy.height / 2 - 6;

      ctx.fillStyle = "red";
      ctx.fillRect(barX, barY, barW, barH);

      ctx.fillStyle = "lime";
      ctx.fillRect(barX, barY, barW * pct, barH);
    }
  }

  drawImageSafely(ctx, image, x, y, w, h) {
    if (image.complete && image.naturalHeight !== 0) {
      ctx.drawImage(image, x, y, w, h);
    } else {
      console.warn("Image not loaded or invalid:", image);
    }
  }
}

=== js/game.js ===
import { EnemyManager } from "./enemyManager.js";
import { TowerManager } from "./towerManager.js";
import { WaveManager }  from "./waveManager.js";

export class Game {
  constructor(
    canvas,
    enemyStatsDiv,
    towerSelectPanel,
    debugTableContainer
  ) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.width = canvas.width;
    this.height = canvas.height;

    this.gold = 200;
    // track both current and max lives for the "x/y" display
    this.lives = 20;
    this.maxLives = 20;

    // Speed handling
    this.speedOptions = [1, 2, 4, 0.5];
    this.speedIndex = 0;
    this.gameSpeed = this.speedOptions[this.speedIndex];

    // Start paused, label will show icon "▶" initially
    this.isFirstStart = true;
    this.paused = true;

    // Level data
    this.levelData = null;
    this.backgroundImg = null;
    this.path = [];
    this.towerSpots = [];

    // Enemies
    this.enemies = [];

    // Global enemy HP multiplier (set from outside; includes the 0.5 factor)
    this.globalEnemyHpMultiplier = 1.0;

    // Managers
    this.enemyManager = new EnemyManager(this);
    this.towerManager = new TowerManager(this);
    this.waveManager  = new WaveManager(this);

    // Main loop
    this.lastTime = 0;

    // Debug mode always on now
    this.debugMode = true;

    // Pause/Resume button
    const pauseBtn = document.getElementById("pauseButton");
    pauseBtn.innerHTML = "&#9658;"; // "▶"
    pauseBtn.addEventListener("click", () => {
      if (this.isFirstStart) {
        this.isFirstStart = false;
        this.paused = false;
        pauseBtn.innerHTML = "&#10073;&#10073;"; // "⏸"
        return;
      }
      this.paused = !this.paused;
      pauseBtn.innerHTML = this.paused ? "&#9658;" : "&#10073;&#10073;";
    });

    // Speed toggle button
    const speedBtn = document.getElementById("speedToggleButton");
    speedBtn.addEventListener("click", () => {
      this.speedIndex = (this.speedIndex + 1) % this.speedOptions.length;
      this.gameSpeed = this.speedOptions[this.speedIndex];
      speedBtn.textContent = `${this.gameSpeed}x`;
    });

    // Canvas click
    this.canvas.addEventListener("click", (e) => this.handleCanvasClick(e));
  }

  setLevelData(data, bgImg) {
    this.levelData = data;
    this.backgroundImg = bgImg;

    const scaleX = this.width / data.mapWidth;
    const scaleY = this.height / data.mapHeight;

    this.path = data.path.map(pt => ({
      x: pt.x * scaleX,
      y: pt.y * scaleY,
    }));
    // Tower spots 2x bigger => store them, but we'll draw radius 20
    this.towerSpots = data.towerSpots.map(s => ({
      x: s.x * scaleX,
      y: s.y * scaleY,
      occupied: false,
    }));

    // Load waves into WaveManager
    this.waveManager.loadWavesFromLevel(data);
  }

  start() {
    requestAnimationFrame((ts) => this.gameLoop(ts));
  }

  gameLoop(timestamp) {
    const delta = (timestamp - this.lastTime) || 0;
    this.lastTime = timestamp;

    // Convert to seconds, then scale by gameSpeed
    let deltaSec = delta / 1000;
    deltaSec *= this.gameSpeed;

    // Update if not paused
    if (!this.paused) {
      this.waveManager.update(deltaSec);
      this.enemyManager.update(deltaSec);
      this.towerManager.update(deltaSec);
    }

    // Always draw
    this.draw();
    requestAnimationFrame((ts) => this.gameLoop(ts));
  }

  handleCanvasClick(e) {
    const rect = this.canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (this.uiManager && this.uiManager.handleCanvasClick) {
      this.uiManager.handleCanvasClick(mx, my, rect);
    }
  }

  draw() {
    if (this.backgroundImg) {
      this.ctx.drawImage(this.backgroundImg, 0, 0, this.width, this.height);
    } else {
      this.ctx.clearRect(0, 0, this.width, this.height);
    }

    // Enemies
    this.enemies.forEach(enemy => {
      this.enemyManager.drawEnemy(this.ctx, enemy);
    });

    // Projectiles
    this.towerManager.drawProjectiles(this.ctx);

    // Towers
    this.towerManager.drawTowers(this.ctx);

    // Tower spots (debug overlay) - radius 20
    this.ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
    this.towerSpots.forEach((spot, i) => {
      this.ctx.beginPath();
      this.ctx.arc(spot.x, spot.y, 20, 0, Math.PI * 2);
      this.ctx.fill();
      if (this.debugMode) {
        this.ctx.fillStyle = "white";
        this.ctx.fillText(`T${i}`, spot.x - 10, spot.y - 25);
        this.ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
      }
    });

    // Path debug
    this.ctx.fillStyle = "yellow";
    this.path.forEach((wp, i) => {
      this.ctx.beginPath();
      this.ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
      this.ctx.fill();
      if (this.debugMode) {
        this.ctx.fillStyle = "white";
        this.ctx.fillText(`P${i}`, wp.x - 10, wp.y - 10);
        this.ctx.fillStyle = "yellow";
      }
    });

    // HUD
    this.ctx.fillStyle = "white";
    this.ctx.fillText(`Gold: ${this.gold}`, 10, 50);
    this.ctx.fillText(
      `Wave: ${this.waveManager.waveIndex + 1}/${this.waveManager.waves.length}`,
      10,
      70
    );
    this.ctx.fillText(`Lives: ${this.lives}/${this.maxLives}`, 10, 90);

    if (
      !this.waveManager.waveActive &&
      this.waveManager.waveIndex < this.waveManager.waves.length
    ) {
      this.ctx.fillText("Next wave is ready", 10, 110);
    }
  }
}

=== js/main.js ===
import { Game } from "./game.js";
import { level1Data } from "./maps/level1.js";
import { UIManager } from "./uiManager.js";
import { loadAllAssets } from "./assetLoader.js";

/**
 * Global parameters:
 * - enemyHpPercent: we use (enemyHpPercent/100) for globalEnemyHpMultiplier
 */
let enemyHpPercent = 100;

let game = null;
let lastStartingGold = 1000; // track so we can re-use it upon restarts

async function startGameWithGold(startingGold) {
  lastStartingGold = startingGold;

  // If there's an old "You lost" or "You win" visible, hide it
  const loseMessage = document.getElementById("loseMessage");
  const winMessage = document.getElementById("winMessage");
  if (loseMessage) loseMessage.style.display = "none";
  if (winMessage) winMessage.style.display = "none";

  const canvas = document.getElementById("gameCanvas");
  const enemyStatsDiv = document.getElementById("enemyStats");
  const towerSelectPanel = document.getElementById("towerSelectPanel");
  const debugTableContainer = document.getElementById("debugTableContainer");

  // Create new Game
  game = new Game(
    canvas,
    enemyStatsDiv,
    towerSelectPanel,
    debugTableContainer
  );

  // Ensure we reset lives and gameOver flags
  game.lives = 20;
  game.maxLives = 20;
  game.gameOver = false;
  if (game.waveManager) {
    game.waveManager.waveIndex = 0;
    game.waveManager.waveActive = false;
  }

  // UI Manager
  const uiManager = new UIManager(
    game,
    enemyStatsDiv,
    towerSelectPanel,
    debugTableContainer,
    loseMessage,
    winMessage
  );
  uiManager.initDebugTable();
  game.uiManager = uiManager;

  // Double from old baseline => (enemyHpPercent / 100)
  game.globalEnemyHpMultiplier = enemyHpPercent / 100;

  // Enemy definitions for loading
  const enemyTypes = [
    { name: "drone",         src: "assets/enemies/drone.png" },
    { name: "leaf_blower",   src: "assets/enemies/leaf_blower.png" },
    { name: "trench_digger", src: "assets/enemies/trench_digger.png" },
    { name: "trench_walker", src: "assets/enemies/trench_walker.png" },
  ];

  // Load images / assets
  const { loadedEnemies, loadedBackground } = await loadAllAssets(
    enemyTypes,
    level1Data.background
  );
  game.enemyManager.setLoadedEnemyAssets(loadedEnemies);

  // Configure level data
  game.setLevelData(level1Data, loadedBackground);

  // Set gold
  game.gold = startingGold;

  // Start
  game.start();

  // Update current game label with a hard return after "Current game:"
  const currentGameLabel = document.getElementById("currentGameLabel");
  if (currentGameLabel) {
    currentGameLabel.innerHTML = `Current game:<br>Starting gold: ${startingGold}, Enemy HP: ${enemyHpPercent}%`;
  }
}

/**
 * On load, initialize the game + set up UI events.
 */
window.addEventListener("load", async () => {
  const startGoldInput = document.getElementById("startingGoldInput");
  const restartGameButton = document.getElementById("restartGameButton");

  // Settings dialog references
  const settingsDialog = document.getElementById("settingsDialog");
  const settingsButton = document.getElementById("settingsButton");
  const settingsDialogClose = document.getElementById("settingsDialogClose");

  // Create segmented HP toggle
  const hpOptions = [];
  for (let v = 80; v <= 120; v += 5) {
    hpOptions.push(v);
  }
  const enemyHpSegment = document.getElementById("enemyHpSegment");
  if (enemyHpSegment) {
    enemyHpSegment.innerHTML = "";
    hpOptions.forEach(value => {
      const btn = document.createElement("button");
      btn.textContent = value + "%";
      btn.classList.add("enemyHpOption");
      // If it's the current selection, highlight
      if (value === enemyHpPercent) {
        btn.style.backgroundColor = "#444";
      }
      btn.addEventListener("click", () => {
        // Clear old highlights
        document.querySelectorAll(".enemyHpOption").forEach(b => {
          b.style.backgroundColor = "";
        });
        // Mark new selection
        enemyHpPercent = value;
        btn.style.backgroundColor = "#444";
      });
      enemyHpSegment.appendChild(btn);
    });
  }

  // Start game with default or user-supplied gold
  await startGameWithGold(parseInt(startGoldInput.value) || 1000);

  // Restart game event
  restartGameButton.addEventListener("click", async () => {
    const desiredGold = parseInt(startGoldInput.value) || 0;
    await startGameWithGold(desiredGold);
  });

  // Toggle the settings dialog on gear click
  settingsButton.addEventListener("click", () => {
    const style = settingsDialog.style.display;
    settingsDialog.style.display = (style === "none" || style === "") ? "block" : "none";
  });

  // Close the settings dialog
  settingsDialogClose.addEventListener("click", () => {
    settingsDialog.style.display = "none";
  });

  // Wire up the lose/win message buttons
  const loseRestartBtn = document.getElementById("loseRestartBtn");
  const loseSettingsBtn = document.getElementById("loseSettingsBtn");
  const winRestartBtn  = document.getElementById("winRestartBtn");
  const winSettingsBtn = document.getElementById("winSettingsBtn");

  if (loseRestartBtn) {
    loseRestartBtn.addEventListener("click", async () => {
      document.getElementById("loseMessage").style.display = "none";
      await startGameWithGold(lastStartingGold);
    });
  }
  if (loseSettingsBtn) {
    loseSettingsBtn.addEventListener("click", () => {
      settingsDialog.style.zIndex = "10001";
      document.getElementById("loseMessage").style.zIndex = "10000";
      settingsDialog.style.display = "block";
    });
  }
  if (winRestartBtn) {
    winRestartBtn.addEventListener("click", async () => {
      document.getElementById("winMessage").style.display = "none";
      await startGameWithGold(lastStartingGold);
    });
  }
  if (winSettingsBtn) {
    winSettingsBtn.addEventListener("click", () => {
      settingsDialog.style.zIndex = "10001";
      document.getElementById("winMessage").style.zIndex = "10000";
      settingsDialog.style.display = "block";
    });
  }

  // If "Restart" is clicked from the settings dialog while a gameOver is showing:
  // We handle that in the restartGameButton click above, which hides loseMessage/winMessage
  restartGameButton.addEventListener("click", () => {
    const loseMessage = document.getElementById("loseMessage");
    const winMessage = document.getElementById("winMessage");
    if (loseMessage) loseMessage.style.display = "none";
    if (winMessage) winMessage.style.display = "none";
  });
});

=== js/maps/level1.js ===
export const level1Data = {
  background: "assets/maps/level1.png",
  mapWidth: 3530,
  mapHeight: 2365,
  path: [
    { x: 420,  y: 0    },
    { x: 800,  y: 860  },
    { x: 1300, y: 1550 },
    { x: 1500, y: 1750 },
    { x: 1950, y: 1920 },
    { x: 3530, y: 1360 },
  ],
  towerSpots: [
    { x: 1020, y: 660  },   // T0
    { x: 620,  y: 1280 },   // T1
    { x: 1340, y: 1080 },   // T2
    { x: 1020, y: 1660 },   // T3
    { x: 1800, y: 1560 },   // T4
    { x: 2080, y: 2150 },   // T5 (inserted)
    { x: 3250, y: 1150 },   // T6
  ],

  /*-----------------------------------------
   | Waves definition 
   | Each wave has multiple "enemy groups."
   |   - type: "drone", "leaf_blower", ...
   |   - count: how many
   |   - spawnInterval: ms between spawns
   |   - hpMultiplier: how much to multiply the base HP
   -----------------------------------------*/
  waves: [
    {
      // Wave 1
      enemyGroups: [
        { type: "drone", count: 5, spawnInterval: 800, hpMultiplier: 1.0 },
      ],
    },
    {
      // Wave 2
      enemyGroups: [
        { type: "drone", count: 3, spawnInterval: 700, hpMultiplier: 1.1 },
        { type: "leaf_blower", count: 2, spawnInterval: 1200, hpMultiplier: 1.1 },
      ],
    },
    {
      // Wave 3
      enemyGroups: [
        { type: "leaf_blower", count: 4, spawnInterval: 1000, hpMultiplier: 1.2 },
        { type: "drone", count: 3, spawnInterval: 700, hpMultiplier: 1.2 },
      ],
    },
    {
      // Wave 4
      enemyGroups: [
        { type: "trench_digger", count: 4, spawnInterval: 900, hpMultiplier: 1.3 },
        { type: "drone", count: 4, spawnInterval: 600, hpMultiplier: 1.3 },
      ],
    },
    {
      // Wave 5
      enemyGroups: [
        { type: "trench_digger", count: 5, spawnInterval: 800, hpMultiplier: 1.4 },
        { type: "leaf_blower", count: 4, spawnInterval: 1200, hpMultiplier: 1.4 },
      ],
    },
    {
      // Wave 6
      enemyGroups: [
        { type: "trench_walker", count: 3, spawnInterval: 1200, hpMultiplier: 1.5 },
        { type: "drone", count: 4, spawnInterval: 600, hpMultiplier: 1.5 },
      ],
    },
    {
      // Wave 7
      enemyGroups: [
        { type: "trench_walker", count: 4, spawnInterval: 1200, hpMultiplier: 1.6 },
        { type: "leaf_blower", count: 3, spawnInterval: 900, hpMultiplier: 1.6 },
      ],
    },
    {
      // Wave 8
      enemyGroups: [
        { type: "drone", count: 6, spawnInterval: 600, hpMultiplier: 1.7 },
        { type: "leaf_blower", count: 4, spawnInterval: 900, hpMultiplier: 1.7 },
        { type: "trench_digger", count: 2, spawnInterval: 800, hpMultiplier: 1.7 },
      ],
    },
    {
      // Wave 9
      enemyGroups: [
        { type: "trench_digger", count: 5, spawnInterval: 700, hpMultiplier: 1.8 },
        { type: "trench_walker", count: 3, spawnInterval: 1300, hpMultiplier: 1.8 },
      ],
    },
    {
      // Wave 10
      enemyGroups: [
        { type: "trench_walker", count: 6, spawnInterval: 1000, hpMultiplier: 1.9 },
        { type: "leaf_blower", count: 5, spawnInterval: 1000, hpMultiplier: 1.9 },
      ],
    },
    // Up to e.g. wave 10 for now (or add more if you want).
  ],
};
=== js/towerManager.js ===
export class TowerManager {
  constructor(game) {
    this.game = game;
    this.towers = [];
    this.projectiles = [];

    // Single data definition for tower types
    // Increase fireRate by 20% => multiply each base fireRate by 0.8
    this.towerTypes = [
      {
        type: "point",
        basePrice: 80,
        range: 169,
        splashRadius: 0,
        fireRate: 1.5 * 0.8, // 1.2
        upgrades: [
          { level: 1, damage: 10, upgradeCost: 0   },
          { level: 2, damage: 15, upgradeCost: 50  },
          { level: 3, damage: 20, upgradeCost: 100 },
          { level: 4, damage: 25, upgradeCost: 150 },
        ],
      },
      {
        type: "splash",
        basePrice: 80,
        range: 104,
        splashRadius: 50,
        fireRate: 1.5 * 0.8, // 1.2
        upgrades: [
          { level: 1, damage: 8,  upgradeCost: 0   },
          { level: 2, damage: 12, upgradeCost: 50  },
          { level: 3, damage: 16, upgradeCost: 100 },
          { level: 4, damage: 20, upgradeCost: 150 },
        ],
      },
    ];
  }

  getTowerData() {
    return this.towerTypes;
  }

  createTower(towerTypeName) {
    const def = this.towerTypes.find(t => t.type === towerTypeName);
    if (!def) return null;

    const firstLvl = def.upgrades[0];
    // Track gold spent (initial build cost)
    return {
      type: def.type,
      level: 1,
      range: def.range,
      damage: firstLvl.damage,
      splashRadius: def.splashRadius,
      fireRate: def.fireRate,
      fireCooldown: 0,
      upgradeCost: def.upgrades[1] ? def.upgrades[1].upgradeCost : 0,
      maxLevel: def.upgrades.length,
      x: 0,
      y: 0,
      spot: null,
      goldSpent: def.basePrice, // store total gold spent
    };
  }

  update(deltaSec) {
    // If gameOver, skip
    if (this.game.gameOver) return;

    // Fire towers
    this.towers.forEach(tower => {
      tower.fireCooldown -= deltaSec;
      if (tower.fireCooldown <= 0) {
        this.fireTower(tower);
        tower.fireCooldown = tower.fireRate;
      }
    });

    // Move projectiles
    this.projectiles.forEach(proj => {
      const step = proj.speed * deltaSec;
      const dx = proj.targetX - proj.x;
      const dy = proj.targetY - proj.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist <= step) {
        proj.x = proj.targetX;
        proj.y = proj.targetY;
        proj.hit = true;
      } else {
        proj.x += (dx / dist) * step;
        proj.y += (dy / dist) * step;
      }
    });

    // Handle collisions
    this.projectiles.forEach(proj => {
      if (proj.hit) {
        if (proj.splashRadius > 0) {
          // Splash damage
          const enemiesHit = this.game.enemies.filter(e => {
            const ex = e.x + e.width / 2;
            const ey = e.y + e.height / 2;
            const dx = proj.targetX - ex;
            const dy = proj.targetY - ey;
            return dx*dx + dy*dy <= proj.splashRadius * proj.splashRadius;
          });
          enemiesHit.forEach(e => {
            if (e === proj.mainTarget) e.hp -= proj.damage;
            else e.hp -= proj.damage / 2;
          });
        } else {
          // Single target
          if (proj.mainTarget) {
            proj.mainTarget.hp -= proj.damage;
          }
        }
      }
    });

    // Clean up projectiles that have hit
    this.projectiles = this.projectiles.filter(p => !p.hit);
  }

  fireTower(tower) {
    const enemiesInRange = this.game.enemies.filter(e => {
      const ex = e.x + e.width / 2;
      const ey = e.y + e.height / 2;
      const dx = ex - tower.x;
      const dy = ey - tower.y;
      return (dx*dx + dy*dy) <= (tower.range * tower.range);
    });
    if (!enemiesInRange.length) return;

    // Lock onto first enemy
    const target = enemiesInRange[0];
    const ex = target.x + target.width / 2;
    const ey = target.y + target.height / 2;

    this.projectiles.push({
      x: tower.x,
      y: tower.y,
      w: 4,
      h: 4,
      speed: 300,
      damage: tower.damage,
      splashRadius: tower.splashRadius,
      mainTarget: target,
      targetX: ex,
      targetY: ey,
      hit: false,
    });
  }

  upgradeTower(tower) {
    const def = this.towerTypes.find(t => t.type === tower.type);
    if (!def) return;
    if (tower.level >= def.upgrades.length) return; // maxed

    const nextLvlIndex = tower.level;
    const nextLvl = def.upgrades[nextLvlIndex];
    if (!nextLvl) return;

    if (this.game.gold < nextLvl.upgradeCost) return;

    // Spend gold
    this.game.gold -= nextLvl.upgradeCost;
    tower.goldSpent += nextLvl.upgradeCost; // track it
    tower.level++;

    tower.damage = nextLvl.damage;
    tower.upgradeCost = def.upgrades[tower.level]
      ? def.upgrades[tower.level].upgradeCost
      : 0;

    // Slightly faster fire rate each upgrade?
    // If you want that, you can do something like: tower.fireRate = tower.fireRate * 0.95, etc.
    // For now, we leave as-is (the base doesn't mention it).
  }

  sellTower(tower) {
    // 80% of goldSpent
    const refund = Math.floor(tower.goldSpent * 0.8);
    this.game.gold += refund;

    // Remove tower from manager
    this.towers = this.towers.filter(t => t !== tower);

    // Free the spot
    if (tower.spot) tower.spot.occupied = false;
  }

  drawTowers(ctx) {
    this.towers.forEach(t => {
      // Tower radius for display
      const drawRadius = 24 + t.level * 4;
      ctx.beginPath();
      ctx.arc(t.x, t.y, drawRadius, 0, Math.PI * 2);
      ctx.fillStyle = (t.type === "point") ? "blue" : "red";
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      // Optional range circle
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.stroke();
    });
  }

  drawProjectiles(ctx) {
    ctx.fillStyle = "yellow";
    this.projectiles.forEach(proj => {
      ctx.fillRect(proj.x - 2, proj.y - 2, proj.w, proj.h);
    });
  }
}

=== js/uiManager.js ===
export class UIManager {
    constructor(
      game,
      enemyStatsDiv,
      towerSelectPanel,
      debugTable,
      loseMessageDiv,
      winMessageDiv
    ) {
      this.game = game;
      this.enemyStatsDiv = enemyStatsDiv;
      this.towerSelectPanel = towerSelectPanel;
      this.debugTable = debugTable;
      this.loseMessageDiv = loseMessageDiv;
      this.winMessageDiv = winMessageDiv;
  
      // Elements inside enemyStatsDiv
      this.enemyImage    = document.getElementById("enemyImage");
      this.enemyNameEl   = document.getElementById("enemyName");
      this.enemyHpEl     = document.getElementById("enemyHp");
      this.enemySpeedEl  = document.getElementById("enemySpeed");
      this.enemyGoldEl   = document.getElementById("enemyGold");
  
      this.selectedEnemy = null;

      // Listen for mouse move to update cursor
      this.game.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e));
    }
  
    initDebugTable() {
      this.debugTable.innerHTML = "";
      const towerData = this.game.towerManager.getTowerData();
      if (!towerData.length) return;
  
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      // Remove the word "Tower" from each header, and right-align columns 2 & 3
      headerRow.innerHTML = `
        <th style="min-width: 120px;"></th>
        <th style="text-align: right;">${towerData[0].type.toUpperCase()}</th>
        <th style="text-align: right;">${towerData[1].type.toUpperCase()}</th>
      `;
      thead.appendChild(headerRow);
      this.debugTable.appendChild(thead);
  
      const tbody = document.createElement("tbody");
  
      // Base Price row
      const basePriceRow = document.createElement("tr");
      basePriceRow.innerHTML = `
        <td><strong>Base Price</strong></td>
        <td style="text-align: right;">$${towerData[0].basePrice}</td>
        <td style="text-align: right;">$${towerData[1].basePrice}</td>
      `;
      tbody.appendChild(basePriceRow);
  
      // Upgrades
      const maxUpgrades = Math.max(
        towerData[0].upgrades.length,
        towerData[1].upgrades.length
      );
  
      for (let i = 0; i < maxUpgrades; i++) {
        const lvl = i + 1;
  
        // damage row
        const rowDamage = document.createElement("tr");
        rowDamage.innerHTML = `
          <td>Level ${lvl} Damage</td>
          <td style="text-align: right;">${towerData[0].upgrades[i] ? towerData[0].upgrades[i].damage : "-"}</td>
          <td style="text-align: right;">${towerData[1].upgrades[i] ? towerData[1].upgrades[i].damage : "-"}</td>
        `;
        tbody.appendChild(rowDamage);
  
        // upgrade cost row (except lvl 1)
        if (lvl > 1) {
          const rowCost = document.createElement("tr");
          rowCost.innerHTML = `
            <td>Level ${lvl} Upgrade Cost</td>
            <td style="text-align: right;">$${towerData[0].upgrades[i] ? towerData[0].upgrades[i].upgradeCost : "-"}</td>
            <td style="text-align: right;">$${towerData[1].upgrades[i] ? towerData[1].upgrades[i].upgradeCost : "-"}</td>
          `;
          tbody.appendChild(rowCost);
        }
      }
  
      this.debugTable.appendChild(tbody);
    }
  
    // Tower click area is the actual drawn radius
    getTowerAt(mx, my) {
      return this.game.towerManager.towers.find(t => {
        const drawRadius = 24 + t.level * 4;
        const dx = mx - t.x;
        const dy = my - t.y;
        return (dx*dx + dy*dy) <= (drawRadius*drawRadius);
      });
    }

    // Unoccupied tower spot clickable area = radius 20
    getTowerSpotAt(mx, my) {
      return this.game.towerSpots.find(s => {
        if (s.occupied) return false;
        const dx = mx - s.x;
        const dy = my - s.y;
        return (dx*dx + dy*dy) <= (20*20);
      });
    }
  
    getEnemyAt(mx, my) {
      return this.game.enemies.find(e => {
        const left   = e.x - e.width / 2;
        const right  = e.x + e.width / 2;
        const top    = e.y - e.height / 2;
        const bottom = e.y + e.height / 2;
        return (mx >= left && mx <= right && my >= top && my <= bottom);
      });
    }
  
    getEntityUnderMouse(mx, my) {
      const tower = this.getTowerAt(mx, my);
      if (tower) {
        return { type: "tower", tower };
      }
      const spot = this.getTowerSpotAt(mx, my);
      if (spot) {
        return { type: "towerSpot", spot };
      }
      const enemy = this.getEnemyAt(mx, my);
      if (enemy) {
        return { type: "enemy", enemy };
      }
      return null;
    }
  
    handleCanvasClick(mx, my, rect) {
      const entity = this.getEntityUnderMouse(mx, my);
  
      if (!entity) {
        // clicked empty space
        this.selectedEnemy = null;
        this.hideEnemyStats();
        this.hideTowerPanel();
        return;
      }
  
      if (entity.type === "towerSpot") {
        this.showNewTowerPanel(entity.spot, rect);
        return;
      }
      if (entity.type === "tower") {
        this.showExistingTowerPanel(entity.tower, rect);
        return;
      }
      if (entity.type === "enemy") {
        this.selectedEnemy = entity.enemy;
        this.showEnemyStats(entity.enemy);
        this.hideTowerPanel();
      }
    }
  
    showExistingTowerPanel(tower, rect) {
      this.towerSelectPanel.innerHTML = "";
      this.towerSelectPanel.style.background = "none";
      this.towerSelectPanel.style.border = "none";
      this.towerSelectPanel.style.borderRadius = "0";
      this.towerSelectPanel.style.textAlign = "center";
  
      const title = document.createElement("div");
      title.style.fontWeight = "bold";
      title.textContent = `${tower.type.toUpperCase()} Tower`;
      this.towerSelectPanel.appendChild(title);

      // Sell Tower button near top, smaller
      const sellBtn = document.createElement("button");
      sellBtn.textContent = "Sell Tower";
      sellBtn.style.display = "block";
      sellBtn.style.margin = "3px auto 6px auto";
      sellBtn.style.fontSize = "0.85em";
      sellBtn.style.padding = "2px 5px";
      sellBtn.addEventListener("click", () => {
        this.game.towerManager.sellTower(tower);
        this.hideTowerPanel();
      });
      this.towerSelectPanel.appendChild(sellBtn);
  
      // Round fireRate to 1 decimal place
      const currentFireRate = Math.round(tower.fireRate * 10) / 10;

      const currStats = document.createElement("div");
      currStats.innerHTML = `
        Level: ${tower.level}<br>
        Damage: ${tower.damage}<br>
        Fire Rate: ${currentFireRate.toFixed(1)}s
      `;
      this.towerSelectPanel.appendChild(currStats);
  
      // Next-level info if not maxed
      if (tower.level < tower.maxLevel) {
        const nextLevel = tower.level + 1;
        const def = this.game.towerManager.getTowerData().find(d => d.type === tower.type);
        if (def) {
          const nextDef = def.upgrades[tower.level]; // tower.level=1 => index=1
          if (nextDef) {
            const nextDamage = nextDef.damage;
            const cost = nextDef.upgradeCost;

            // If we want the next level's rate to be (base - 0.2) or something:
            // We'll do a simple 0.2 improvement for now, then round to 1 decimal
            const nextRate = Math.round(Math.max(0.1, tower.fireRate - 0.2) * 10)/10;

            const nextStats = document.createElement("div");
            nextStats.innerHTML = `
              <hr>
              <strong>Next Level ${nextLevel}:</strong><br>
              Damage: ${nextDamage}<br>
              Fire Rate: ${nextRate.toFixed(1)}s<br>
              Upgrade Cost: $${cost}
            `;
            this.towerSelectPanel.appendChild(nextStats);
  
            const upgradeBtn = document.createElement("button");
            upgradeBtn.textContent = "Upgrade";
            upgradeBtn.disabled = (this.game.gold < cost);
            upgradeBtn.addEventListener("click", () => {
              this.game.towerManager.upgradeTower(tower);
              this.hideTowerPanel();
            });
            this.towerSelectPanel.appendChild(upgradeBtn);
          }
        }
      } else {
        const maxed = document.createElement("div");
        maxed.style.marginTop = "6px";
        maxed.textContent = "Tower is at max level.";
        this.towerSelectPanel.appendChild(maxed);
      }
  
      // Show, measure, then position
      this.towerSelectPanel.style.display = "block";
      const panelW = this.towerSelectPanel.offsetWidth;
      const panelH = this.towerSelectPanel.offsetHeight;
  
      const towerScreenX = tower.x + rect.left;
      const towerScreenY = tower.y + rect.top;
      this.towerSelectPanel.style.left = (towerScreenX - panelW / 2) + "px";
      this.towerSelectPanel.style.top  = (towerScreenY - panelH) + "px";
    }
  
    showNewTowerPanel(spot, rect) {
      this.towerSelectPanel.innerHTML = "";
      this.towerSelectPanel.style.background = "none";
      this.towerSelectPanel.style.border = "none";
      this.towerSelectPanel.style.borderRadius = "0";
      this.towerSelectPanel.style.textAlign = "center";
  
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "10px";
      container.style.justifyContent = "center";
      container.style.alignItems = "flex-start";
  
      const towerDefs = this.game.towerManager.getTowerData();
      towerDefs.forEach(def => {
        const towerDiv = document.createElement("div");
        towerDiv.style.background = "rgba(0,0,0,0.7)";
        towerDiv.style.border = "1px solid #999";
        towerDiv.style.padding = "4px";
        towerDiv.style.borderRadius = "4px";
        towerDiv.style.minWidth = "80px";
  
        const nameEl = document.createElement("div");
        nameEl.style.fontWeight = "bold";
        nameEl.textContent = def.type.toUpperCase();
        towerDiv.appendChild(nameEl);

        // Round fireRate to 1 decimal for display
        const displayRate = Math.round(def.fireRate * 10) / 10;

        const statsEl = document.createElement("div");
        statsEl.innerHTML = `DMG: ${def.upgrades[0].damage}<br>Rate: ${displayRate.toFixed(1)}s`;
        towerDiv.appendChild(statsEl);
  
        const buildBtn = document.createElement("button");
        buildBtn.textContent = `$${def.basePrice}`;
        buildBtn.addEventListener("click", () => {
          if (this.game.gold >= def.basePrice && !spot.occupied) {
            this.game.gold -= def.basePrice;
            const newTower = this.game.towerManager.createTower(def.type);
            newTower.x = spot.x;
            newTower.y = spot.y;
            newTower.spot = spot;
            spot.occupied = true;
            this.game.towerManager.towers.push(newTower);
          }
          this.hideTowerPanel();
        });
        towerDiv.appendChild(buildBtn);
  
        container.appendChild(towerDiv);
      });
  
      this.towerSelectPanel.appendChild(container);
  
      this.towerSelectPanel.style.display = "block";
      const panelW = this.towerSelectPanel.offsetWidth;
      const panelH = this.towerSelectPanel.offsetHeight;
  
      const spotScreenX = spot.x + rect.left;
      const spotScreenY = spot.y + rect.top;
      this.towerSelectPanel.style.left = (spotScreenX - panelW / 2) + "px";
      this.towerSelectPanel.style.top  = (spotScreenY - panelH) + "px";
    }
  
    hideTowerPanel() {
      this.towerSelectPanel.style.display = "none";
    }
  
    showEnemyStats(enemy) {
      this.enemyStatsDiv.style.display = "block";
      this.enemyImage.src          = enemy.image.src;
      this.enemyNameEl.textContent = enemy.name;
      this.enemyHpEl.textContent   = `${enemy.hp.toFixed(1)}/${enemy.baseHp.toFixed(1)}`;
      this.enemySpeedEl.textContent= enemy.speed.toFixed(1);
      this.enemyGoldEl.textContent = enemy.gold;
    }
  
    hideEnemyStats() {
      this.enemyStatsDiv.style.display = "none";
    }

    /**
     * Called by enemyManager when lives <= 0
     */
    showLoseDialog() {
      this.loseMessageDiv.style.display = "block";
      // Mark game over so it doesn't keep updating
      this.game.gameOver = true;
    }

    /**
     * Called by waveManager on final wave completion if we still have >0 lives
     */
    showWinDialog(finalLives, maxLives) {
      this.winMessageDiv.style.display = "block";
      // Mark game over
      this.game.gameOver = true;

      const starsDiv = this.winMessageDiv.querySelector("#winStars");
      let starCount = 1;
      if (finalLives >= 18) {
        starCount = 3;
      } else if (finalLives >= 10) {
        starCount = 2;
      }
      const starSymbols = [];
      for(let i=1; i<=3; i++){
        if (i <= starCount) starSymbols.push("★");
        else starSymbols.push("☆");
      }
      if(starsDiv) starsDiv.innerHTML = starSymbols.join(" ");
    }

    // Update mouse cursor to pointer if over tower or enemy
    handleMouseMove(e) {
      const rect = this.game.canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
  
      const entity = this.getEntityUnderMouse(mx, my);
      if (entity && (entity.type === "tower" || entity.type === "enemy")) {
        this.game.canvas.style.cursor = "pointer";
      } else if (entity && entity.type === "towerSpot") {
        // Could also set to "pointer" if you want an indication for building
        this.game.canvas.style.cursor = "pointer";
      } else {
        this.game.canvas.style.cursor = "default";
      }
    }
}

=== js/waveManager.js ===
export class WaveManager {
  constructor(game) {
    this.game = game;

    this.waveIndex = 0;
    this.waveActive = false;

    // Start with no forced delay
    this.timeUntilNextWave = 0;

    this.waves = [];
  }

  loadWavesFromLevel(levelData) {
    this.waves = (levelData && levelData.waves) || [];
    console.log("Waves loaded (reloaded):", this.waves);
  }

  update(deltaSec) {
    // If wave not active, see if there's another wave to start
    if (!this.waveActive && this.waveIndex < this.waves.length) {
      this.timeUntilNextWave -= deltaSec;
      if (this.timeUntilNextWave <= 0) {
        this.startWave(this.waveIndex);
      }
    }

    // Check if the current wave is finished
    if (this.waveActive) {
      const waveInfo = this.waves[this.waveIndex];
      const allSpawned = waveInfo.enemyGroups.every(g => g.spawnedCount >= g.count);
      if (allSpawned && this.game.enemies.length === 0) {
        // wave done
        this.waveActive = false;
        this.waveIndex++;

        if (this.waveIndex >= this.waves.length) {
          // That was the last wave
          // If the game hasn't been lost, show "You win"
          if (this.game.lives > 0 && this.game.uiManager) {
            this.game.paused = true;
            this.game.uiManager.showWinDialog(this.game.lives, this.game.maxLives);
          }
        } else {
          // prepare next wave
          this.timeUntilNextWave = 0;
        }
      }
    }
  }

  startWave(index) {
    this.waveActive = true;
    const waveInfo = this.waves[index];

    waveInfo.enemyGroups.forEach(group => {
      group.spawnedCount = 0;
      const timer = setInterval(() => {
        if (group.spawnedCount >= group.count) {
          clearInterval(timer);
          return;
        }
        this.spawnEnemyGroup(group);
        group.spawnedCount++;
      }, group.spawnInterval);
    });
  }

  spawnEnemyGroup(group) {
    this.game.enemyManager.spawnEnemy(group.type, group.hpMultiplier);
  }

  sendWaveEarly() {
    if (!this.waveActive && this.waveIndex < this.waves.length) {
      this.startWave(this.waveIndex);
    }
  }
}

